%name LL::Parser;

%terminals T_RUBY T_NAME T_TERMINALS T_INNER T_HEADER T_IDENT T_EQUALS T_COLON;
%terminals T_PIPE T_STAR T_PLUS T_QUESTION T_EPSILON T_SEMICOLON;

grammar = element*;

element
  = directive
  | rule
  ;

directive
  = name
  | terminals
  | inner
  | header
  ;

# %name directives
#
# This handles the parsing of %name directives, which can either contain a
# single name (e.g. "Foo") or a Ruby namespace (e.g. "Foo::Bar").

name = T_NAME T_IDENT name_ns* T_SEMICOLON;

name_ns = T_COLON T_COLON T_IDENT;

# Generic Directives

terminals = T_TERMINALS idents T_SEMICOLON;

# Code Directives
#
# These are directives that can be used to specify inline Ruby code (e.g. %inner
# and %header).

inner  = T_INNER T_RUBY;
header = T_HEADER T_RUBY;

# Generic identifiers

idents = ident+;
ident  = T_IDENT;

# Identifiers with/without named captures and/or operators.

idents_or_epsilon
  = ident_or_capture+
  | T_EPSILON
  ;

ident_or_capture = ident ident_or_capture_follow;

ident_or_capture_follow
  = T_COLON ident operator?
  | operator?
  ;

# Rules

branch = idents_or_epsilon T_RUBY?;

branches = branch branches_follow*;

branches_follow = T_PIPE branches;

rule = ident T_EQUALS branches T_SEMICOLON;

# Operators

operator
  = T_STAR
  | T_PLUS
  | T_QUESTION
  ;

%inner
{
  ##
  # @param [String] input
  #
  def initialize(*args)
    @lexer = Lexer.new(*args)

    setup
  end

  ##
  # @yieldparam [Symbol] type
  # @yieldparam [String] value
  #
  def each_token
    @lexer.advance do |type, value, source_line|
      @source_line = source_line

      yield [type, value]
    end

    yield [-1, -1]
  ensure
    @source_line = nil
  end

  ##
  # @param [Symbol] type
  # @param [Array] children
  # @return [LL::AST::Node]
  #
  def s(type, *children)
    return AST::Node.new(type, children, :source_line => @source_line)
  end
}
