%name LL::Parser;

%terminals T_RUBY T_NAME T_TERMINALS T_INNER T_HEADER T_IDENT T_EQUALS T_COLON;
%terminals T_PIPE T_EPSILON T_SEMICOLON;

grammar
  = elements
  ;

elements
  = element elements
  | _;

element
  = directive
  | rule
  ;

directive
  = name
  | terminals
  | inner
  | header
  ;

# %name directives
#
# This handles the parsing of %name directives, which can either contain a
# single name (e.g. "Foo") or a Ruby namespace (e.g. "Foo::Bar").

name = T_NAME T_IDENT namespace_parts T_SEMICOLON;

namespace_parts
  = namespace_part namespace_parts
  | _
  ;

namespace_part = T_COLON T_COLON T_IDENT;

# Generic Directives

terminals = T_TERMINALS idents T_SEMICOLON;

# Code Directives
#
# These are directives that can be used to specify inline Ruby code (e.g. %inner
# and %header).

inner  = T_INNER T_RUBY;
header = T_HEADER T_RUBY;

# Generic identifiers

idents = ident idents_follow;

idents_follow
  = idents
  | _
  ;

ident = T_IDENT;

# Identifiers

idents_or_epsilon
  = idents
  | T_EPSILON
  ;

# Rules

branch = idents_or_epsilon branch_ruby;

branch_ruby
  = T_RUBY
  | _
  ;

branches = branch branches_follow;

branches_follow
  = T_PIPE branches
  | _
  ;

rule = ident T_EQUALS branches T_SEMICOLON;

%inner
{
  ##
  # @param [String] input
  #
  def initialize(*args)
    @lexer = Lexer.new(*args)
  end

  ##
  # @see [LL::Driver#stack_input_error]
  #
  def stack_input_error(stack_value, token)
    type = token[0].inspect
    sl   = token[1].source_line

    raise(
      ParserError,
      "Unexpected rule #{stack_value} for #{type} on line #{sl.line}, " \
        "column #{sl.column}"
    )
  end

  ##
  # @yieldparam [Symbol] type
  # @yieldparam [String] value
  #
  def each_token
    @lexer.advance do |token|
      yield [token.type, token]
    end

    yield [-1, -1]
  end

  ##
  # @param [Symbol] type
  # @param [Array] children
  # @return [LL::AST::Node]
  #
  def s(*args)
    return AST::Node.new(*args)
  end
}
