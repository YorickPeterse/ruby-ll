# The name of the parser class
name = JsonParser

# Definition of all the terminals. Unrecognized terminals trigger a
# compilation error.
tokens = T_LCURLY T_RCURLY T_COMMA T_STRING T_INT T_COLON

precedence do
  left A B C # These all have the same precedence
  left X Y Z # Same here, but they're lower than A, B and C
end

# The start of all the rules. The rule declared first will be the entry rule
# of the parser.
#
# General syntax of a rule is as following:
#
#     NAME : X | Y | Z
#
# You can use "..." to denote an epsilon/nil/null value. For example:
#
#     foo = X | ...
#
# This would match "X" or nothing.
#
# Repetition can be applied using either recursion or by using ?, * and/or +:
#
#     numbers      = number more_numbers
#     more_numbers = numbers | ...
#
# Which is basically:
#
#     numbers = number+
#
# And using *:
#
#     numbers = number*
#
# Is basically:
#
#     numbers      = number | more_numbers
#     more_numbers = number | ...
#
# And using ?:
#
#     numbers = number?
#
# Is basically:
#
#     numbers = number | ...
rules do
  json
    : T_LCURLY values T_RCURLY { val[1] }

  values
    : pair more_values
      {
        new_hash = val[0]

        if val[1]
          val[1].each do |key, value|
            new_hash[key] = value
          end
        end

        new_hash
      }

  # Alternatively the above could be this:
  #
  # values = pair pair*
  #
  # Or (with pairs being optional):
  #
  # values = pair*
  #
  # Which is basically the same as this:
  #
  # value = pair | pair value | ...
  #

  more_values
    : T_COMMA values { val[1] }
    | ...            { {} }

  pair
    : T_STRING T_COLON value { {val[0] => val[2]} }

  # Named captures are also available:
  pair
    : T_STRING:key T_COLON value:value { {key => value} }

  array
    : value*
    | value (T_COMMA value)*

  value
    : T_STRING { val[0] }
    | T_INT    { val[0].to_i }
end

# Everything in this block will be injected into the generated class' body,
# just after all the parsing boilerplate. This is similar to Racc's
# ---- inner directive.
inner do
  def initialize(input)
    @tokens = Lexer.new(input).lex
  end

  # This has to yield an Array containing the terminal/token type and its
  # value. The last token yielded must be [-1, -1].
  def each_token

  end
end

# vim: set ft=ruby:
